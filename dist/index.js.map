{"version":3,"sources":["../src/context/WizardContext.tsx","../src/adapters/persistence/MemoryAdapter.ts","../src/utils/data.ts","../src/hooks/useWizard.ts","../src/adapters/persistence/LocalStorageAdapter.ts","../src/adapters/validation/ZodAdapter.ts","../src/adapters/validation/YupAdapter.ts"],"sourcesContent":["import React, { createContext, useContext, useEffect, useMemo, useState, useCallback } from 'react';\nimport type {\n  IWizardConfig,\n  IWizardContext,\n  PersistenceMode,\n  IPersistenceAdapter,\n} from '../types';\nimport { MemoryAdapter } from '../adapters/persistence/MemoryAdapter';\nimport { getByPath, setByPath } from '../utils/data';\n\nconst WizardContext = createContext<IWizardContext<any> | undefined>(undefined);\n\ninterface WizardProviderProps<T> {\n  config: IWizardConfig<T>;\n  initialData?: T;\n  children: React.ReactNode;\n}\n\nexport function WizardProvider<T extends Record<string, any>>({\n  config,\n  initialData,\n  children,\n}: WizardProviderProps<T>) {\n  const [currentStepId, setCurrentStepId] = useState<string>('');\n  const [wizardData, setWizardData] = useState<T>((initialData || {}) as T);\n  const [visitedSteps, setVisitedSteps] = useState<Set<string>>(new Set());\n  const [completedSteps, setCompletedSteps] = useState<Set<string>>(new Set());\n  const [errorSteps, setErrorSteps] = useState<Set<string>>(new Set());\n  const [allErrors, setAllErrors] = useState<Record<string, Record<string, string>>>({});\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n\n  // Persistence Setup\n  const persistenceAdapter = useMemo<IPersistenceAdapter>(() => {\n    return config.persistence?.adapter || new MemoryAdapter();\n  }, [config.persistence?.adapter]);\n\n  const persistenceMode = config.persistence?.mode || 'onStepChange';\n\n  // Calculate Active Steps (Conditional Logic)\n  const activeSteps = useMemo(() => {\n    return config.steps.filter((step) => {\n      if (step.condition) {\n        return step.condition(wizardData);\n      }\n      return true;\n    });\n  }, [config.steps, wizardData]);\n\n  // Set initial step if not set\n  useEffect(() => {\n    if (!currentStepId && activeSteps.length > 0) {\n      setCurrentStepId(activeSteps[0].id);\n      setIsLoading(false);\n    }\n  }, [activeSteps, currentStepId]);\n\n  // Derived state\n  const currentStep = useMemo(() => activeSteps.find((s) => s.id === currentStepId) || null, [activeSteps, currentStepId]);\n  const currentStepIndex = useMemo(() => activeSteps.findIndex((s) => s.id === currentStepId), [activeSteps, currentStepId]);\n  const isFirstStep = currentStepIndex === 0;\n  const isLastStep = currentStepIndex === activeSteps.length - 1;\n\n  // Constants\n  const META_KEY = '__wizzard_meta__';\n\n  // Hydration Helper\n  const hydrate = useCallback(() => {\n    setIsLoading(true);\n    \n    // 1. Load Metadata (Current Step, Visited, etc.)\n    const metaFn = persistenceAdapter.getStep<{\n      currentStepId: string;\n      visited: string[];\n      completed: string[];\n    }>(META_KEY);\n\n    if (metaFn) {\n       if (metaFn.currentStepId) setCurrentStepId(metaFn.currentStepId);\n       if (metaFn.visited) setVisitedSteps(new Set(metaFn.visited));\n       if (metaFn.completed) setCompletedSteps(new Set(metaFn.completed));\n    }\n\n    // 2. Load Data\n    // We assume data is distributed across steps OR stored centrally.\n    // Given the current implementation saves 'wizardData' to each stepId, \n    // we can iterate steps.\n    const loadedData: Partial<T> = {};\n    config.steps.forEach(step => {\n       const stepData = persistenceAdapter.getStep(step.id);\n       if (stepData) {\n         Object.assign(loadedData, stepData);\n       }\n    });\n\n    if (Object.keys(loadedData).length > 0) {\n        setWizardData(prev => ({ ...prev, ...loadedData }));\n    }\n    setIsLoading(false);\n  }, [config.steps, persistenceAdapter]);\n\n  useEffect(() => {\n    hydrate();\n  }, [hydrate]);\n\n  // Save logic\n  const saveData = useCallback((mode: PersistenceMode, stepId: string, data: any) => {\n    if (mode === persistenceMode || mode === 'manual') {\n        persistenceAdapter.saveStep(stepId, data);\n        \n        // Also save metadata whenever we save data (if appropriate)\n        // Or we can save metadata explicitly on navigation.\n    }\n  }, [persistenceAdapter, persistenceMode]);\n\n  // Explicit Metadata Save\n\n  // Action: Set Step Data\n  const setStepData = useCallback((stepId: string, data: any) => {\n    setWizardData((prev) => {\n      const newData = { ...prev, ...data };\n      // Save if mode is 'onChange'\n      if (persistenceMode === 'onChange') {\n         // We must save the FULL new data, not just the partial 'data' update, \n         // otherwise we overwrite the storage with just the single field.\n         saveData('onChange', stepId, newData); \n      }\n      return newData;\n    });\n  }, [persistenceMode, saveData]);\n\n  // Action: Set Data by Path\n  const setData = useCallback((path: string, value: any) => {\n    setWizardData((prev) => {\n      const newData = setByPath(prev, path, value);\n      \n      if (persistenceMode === 'onChange') {\n        saveData('onChange', currentStepId, newData);\n      }\n      return newData;\n    });\n  }, [persistenceMode, saveData, currentStepId]);\n\n  // Action: Get Data by Path\n  const getData = useCallback((path: string, defaultValue?: any) => {\n    return getByPath(wizardData, path, defaultValue);\n  }, [wizardData]);\n\n  // Action: Handle specific field change (helper)\n  const handleStepChange = useCallback((field: string, value: any) => {\n    if (!currentStepId) return;\n    setData(field, value);\n  }, [setData, currentStepId]);\n  \n  // Validation Logic\n  const validateStep = useCallback(async (stepId: string): Promise<boolean> => {\n    const step = config.steps.find(s => s.id === stepId);\n    if (!step) return true;\n    \n    // Check if adapter exists\n    if (!step.validationAdapter) return true;\n\n    const result = await step.validationAdapter.validate(wizardData);\n    \n    if (!result.isValid) {\n      setAllErrors(prev => ({\n        ...prev,\n        [stepId]: result.errors || {}\n      }));\n      setErrorSteps(prev => new Set(prev).add(stepId));\n      return false;\n    } else {\n      setAllErrors(prev => {\n        const next = { ...prev };\n        delete next[stepId];\n        return next;\n      });\n      setErrorSteps(prev => {\n        const next = new Set(prev);\n        next.delete(stepId);\n        return next;\n      });\n      return true;\n    }\n  }, [config.steps, wizardData]);\n\n  const validateAll = useCallback(async (): Promise<boolean> => {\n    let isValid = true;\n    for (const step of activeSteps) {\n      const stepValid = await validateStep(step.id);\n      if (!stepValid) isValid = false;\n    }\n    return isValid;\n  }, [activeSteps, validateStep]);\n\n  // Navigation\n  const goToStep = useCallback(async (stepId: string): Promise<boolean> => {\n    const targetIndex = activeSteps.findIndex(s => s.id === stepId);\n    if (targetIndex === -1) return false;\n\n    // If moving forward, validate current\n    if (targetIndex > currentStepIndex) {\n       const shouldValidate = currentStep?.autoValidate ?? config.autoValidate ?? true;\n       if (shouldValidate) {\n         const isValid = await validateStep(currentStepId);\n         if (!isValid) return false; // Block\n       }\n    }\n    \n    // Save current step data logic\n    if (persistenceMode === 'onStepChange' && currentStep) {\n        saveData('onStepChange', currentStepId, wizardData); \n    }\n\n    // Update State\n    const nextVisited = new Set(visitedSteps).add(currentStepId);\n    setVisitedSteps(nextVisited);\n    setCurrentStepId(stepId);\n    \n    // Persist Metadata (New Step Position)\n    // We need to pass the *new* values because state updates are async\n    if (persistenceMode !== 'manual') {\n        persistenceAdapter.saveStep(META_KEY, {\n            currentStepId: stepId,\n            visited: Array.from(nextVisited),\n            completed: Array.from(completedSteps)\n        });\n    }\n\n    window.scrollTo(0, 0);\n    return true;\n  }, [activeSteps, currentStepId, currentStep, currentStepIndex, config.autoValidate, persistenceMode, saveData, wizardData, validateStep, visitedSteps, completedSteps, persistenceAdapter]);\n\n  const goToNextStep = useCallback(async () => {\n     if (isLastStep) return;\n     const nextStep = activeSteps[currentStepIndex + 1];\n     if (nextStep) {\n        // Validation happens inside goToStep. If it fails, we shouldn't mark as completed.\n        const success = await goToStep(nextStep.id);\n        \n        if (success) {\n            // Mark completed logic ONLY on success\n            const nextCompleted = new Set(completedSteps).add(currentStepId);\n            setCompletedSteps(nextCompleted);\n            \n            // We need to update metadata again to include the new 'completed' status.\n            // The previous save in goToStep didn't know about this new completion.\n             if (persistenceMode !== 'manual') {\n                 persistenceAdapter.saveStep(META_KEY, {\n                     currentStepId: nextStep.id,\n                     visited: Array.from(new Set(visitedSteps).add(currentStepId)),\n                     completed: Array.from(nextCompleted) // Updated completed steps\n                 });\n             }\n        }\n     }\n  }, [activeSteps, currentStepIndex, isLastStep, currentStepId, goToStep, visitedSteps, completedSteps, persistenceMode, persistenceAdapter]);\n\n  const goToPrevStep = useCallback(() => {\n     if (isFirstStep) return;\n     const prevStep = activeSteps[currentStepIndex - 1];\n     if (prevStep) {\n       goToStep(prevStep.id);\n     }\n  }, [activeSteps, currentStepIndex, isFirstStep, goToStep]);\n\n  // Context Value\n  const value = {\n    currentStep,\n    currentStepIndex,\n    isFirstStep,\n    isLastStep,\n    isLoading,\n    activeSteps,\n    wizardData,\n    allErrors,\n    visitedSteps,\n    completedSteps,\n    errorSteps,\n    goToNextStep,\n    goToPrevStep,\n    goToStep,\n    setStepData,\n    handleStepChange,\n    validateStep,\n    validateAll,\n    save: useCallback(() => saveData('manual', currentStepId, wizardData), [saveData, currentStepId, wizardData]),\n    clearStorage: useCallback(() => persistenceAdapter.clear(), [persistenceAdapter]),\n    setData,\n    getData,\n  };\n\n  return <WizardContext.Provider value={value}>{children}</WizardContext.Provider>;\n}\n\nexport function useWizardContext<T = any>() {\n  const context = useContext(WizardContext);\n  if (!context) {\n    throw new Error('useWizardContext must be used within a WizardProvider');\n  }\n  return context as IWizardContext<T>;\n}\n","import type { IPersistenceAdapter } from '../../types';\n\nexport class MemoryAdapter implements IPersistenceAdapter {\n    private storage: Record<string, any> = {};\n\n    saveStep<T>(stepId: string, data: T): void {\n        this.storage[stepId] = data;\n    }\n\n    getStep<T>(stepId: string): T | undefined {\n        return this.storage[stepId] as T;\n    }\n\n    clear(): void {\n        this.storage = {};\n    }\n}\n","/**\n * Retrieves a value from an object by path (dot notation or brackets)\n */\nexport function getByPath(obj: any, path: string, defaultValue?: any): any {\n    if (!path) return obj;\n    const keys = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.').filter(Boolean);\n    let result = obj;\n    for (const key of keys) {\n        if (result === undefined || result === null) return defaultValue;\n        result = result[key];\n    }\n    return result !== undefined ? result : defaultValue;\n}\n\n/**\n * Immutably sets a value in an object by path\n */\nexport function setByPath<T extends object>(obj: T, path: string, value: any): T {\n    if (!path) return value as unknown as T;\n    const keys = path.replace(/\\[(\\d+)\\]/g, '.$1').split('.').filter(Boolean);\n\n    const update = (current: any, index: number): any => {\n        if (index === keys.length) return value;\n\n        const key = keys[index];\n        const isKeyNumeric = !isNaN(Number(key)) && key.trim() !== '';\n\n        let nextLevel = current;\n        if (!nextLevel || typeof nextLevel !== 'object') {\n            nextLevel = isKeyNumeric ? [] : {};\n        } else {\n            nextLevel = Array.isArray(nextLevel) ? [...nextLevel] : { ...nextLevel };\n        }\n\n        const nextKey = isKeyNumeric ? Number(key) : key;\n        nextLevel[nextKey] = update(nextLevel[nextKey], index + 1);\n        return nextLevel;\n    };\n\n    return update(obj, 0);\n}\n","import { useWizardContext } from '../context/WizardContext';\n\nexport const useWizard = <T = any>() => {\n    return useWizardContext<T>();\n};\n","import type { IPersistenceAdapter } from '../../types';\n\nexport class LocalStorageAdapter implements IPersistenceAdapter {\n    private prefix: string;\n\n    constructor(prefix: string = 'wizard_') {\n        this.prefix = prefix;\n    }\n\n    private getKey(stepId: string): string {\n        return `${this.prefix}${stepId}`;\n    }\n\n    saveStep<T>(stepId: string, data: T): void {\n        if (typeof window === 'undefined') return;\n        try {\n            localStorage.setItem(this.getKey(stepId), JSON.stringify(data));\n        } catch (error) {\n            console.warn('LocalStorageAdapter: Failed to save step', error);\n        }\n    }\n\n    getStep<T>(stepId: string): T | undefined {\n        if (typeof window === 'undefined') return undefined;\n        try {\n            const item = localStorage.getItem(this.getKey(stepId));\n            return item ? JSON.parse(item) : undefined;\n        } catch (error) {\n            console.warn('LocalStorageAdapter: Failed to get step', error);\n            return undefined;\n        }\n    }\n\n    clear(): void {\n        if (typeof window === 'undefined') return;\n        Object.keys(localStorage).forEach((key) => {\n            if (key.startsWith(this.prefix)) {\n                localStorage.removeItem(key);\n            }\n        });\n    }\n}\n","import type { IValidatorAdapter, ValidationResult } from '../../types';\nimport { ZodType } from 'zod';\n\nexport class ZodAdapter<T> implements IValidatorAdapter<T> {\n    private schema: ZodType<T>;\n\n    constructor(schema: ZodType<T>) {\n        this.schema = schema;\n    }\n\n    async validate(data: T): Promise<ValidationResult> {\n        const result = await this.schema.safeParseAsync(data);\n        if (result.success) {\n            return { isValid: true };\n        }\n\n        // Explicitly handle error case\n        const errors: Record<string, string> = {};\n        result.error.issues.forEach((err) => {\n            const path = err.path.join('.'); // nested.field\n            errors[path] = err.message;\n        });\n        return { isValid: false, errors };\n    }\n}\n","import type { IValidatorAdapter, ValidationResult } from '../../types';\nimport { Schema, ValidationError } from 'yup';\n\nexport class YupAdapter<T> implements IValidatorAdapter<T> {\n    private schema: Schema<T>;\n\n    constructor(schema: Schema<T>) {\n        this.schema = schema;\n    }\n\n    async validate(data: T): Promise<ValidationResult> {\n        try {\n            await this.schema.validate(data, { abortEarly: false });\n            return { isValid: true };\n        } catch (err) {\n            if (err instanceof ValidationError) {\n                const errors: Record<string, string> = {};\n                err.inner.forEach((error) => {\n                    if (error.path) {\n                        errors[error.path] = error.message;\n                    }\n                });\n                return { isValid: false, errors };\n            }\n            throw err;\n        }\n    }\n}\n"],"mappings":"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","names":["value"]}